# Serving : 모델을 세상으로
- Serving의 정의
	- 모델의 예측 결과를 요청한 Client에게 제공하는 과정
	- 유튜브, deepl 등
- Serving의 종류
	- Batch Serving
		- 데이터를 일정 묶음 단위로 서빙(예 : 정해진 시간에 갱신하는 서비스)
		- 실시간 응답이 중요하지 않은 경우, 대량의 데이터를 처리할 때, 정기적인 일정의 경우
		- 인력이 적은 경우, 데이터가 RDB, 데이터 웨어하우스에 저장되어 있는 경우
	- Online Serving
		- 클라이언트가 요청할 때 서빙
		- 실시간 응답이 중요한 경우, 개별 요청 맞춤 처리가 중요할 때, 동적인 데이터에 대응할 때
		- 인력이 충분한 경우, 요청할 때 같이 데이터 제공할 때(API)
		- 예시 : 유튜브의 추천 시스템, 번역 등
# 단순한 Serving 패턴
- 디자인 패턴
	- 코드의 재사용성, 가독성, 확장성을 고려하여 문제 해결에서 반복된 내용을 패턴으로 정리
- 머신러닝 디자인 패턴
	- 머신러닝은 Data, Model, Code의 존재로 별도의 디자인 패턴이 생김
	- 고려할 점
		- 대용량 Model Load 및 Model 관리
		- 대량의 데이터 처리
		- 모델연산에 따른 반응 시간 지연
	- Batch Serving 패턴
		- Batch 패턴
			![[Pasted image 20241211163247.png]]
			- 주기적으로 예측 결과를 DB에 저장하고, 활용하는 쪽은 DB에서 결과를 읽어와서 사용
			- 구성 요소
				- Job
					- 어떤 작업 실행에 필요한 모든 활동 - Model Load, Data Load 포함
					- Python Script를 그냥 실행시키는 경우도 있고, Docker Image로 실행하는 경우도 존재
				- Job Management Server
					- 작업을 실행하는 서버
					- Apche Airflow 등을 주로 사용
					- 특정 시간에 주기적으로 Batch Job을 실행시키는 주체
				- Data
					- DB 또는 데이터 웨어하우스에 저장
					- 서비스 서버에서도 데이터를 불러오는 스케줄링Job이 존재 - 특정 시간 단위
			- 장점
				- 기존에 사용하던 코드 재사용 가능
				- API 서버를 개발하지 않아도 됨
				- 서버 리소스 관리 유연
			- 고민할 점
				- 별도의 스케줄러 필요
	- Online Serving 패턴
		- Web Single 패턴
			![[Pasted image 20241211163916.png]]
			- 모델이 항상 Load된 상태에서 예측을 해주는 API 서버를 만들고, 서비스 서버에서 예측 서버에 직접 요청
			- 구성 요소
				- 예측/추론 Server
					- FastAPI 등으로 단일 REST API 서버를 개발 후 배포
					- API 서버가 실행될 때 모델을 로드
					- API 로직 내에 전처리도 같이 포함
				- Client
					- 앱에서 직접 요청 또는 앱 -> 서비스서버 -> 예측서버 요청
				- Data
					- 요청할 때 데이터를 담아서 요청
					- 상황에 따라 용량 제한
				- Load Balancer
			- 장점
				- 보통 하나의 프로그래밍 언어 사용
				- 단순한 아키텍처
			- 고민할 점
				- 구성 요소 하나가 바뀌면 전체 업데이트 필요
				- 모델이 큰 경우 로드에 오랜 시간
				- 서버에 부하 우려
			-  Usecase
				- 예측 서버를 빠르게 출시하고 싶은 경우
				- 예측 결과를 실시간으로 얻고 싶은 경우
				- 이 패턴을 기본으로 삼고 이어지는 패턴들을 적용
		- Synchronous 패턴
			![[Pasted image 20241211164913.png]]
			- 장점
				- 단순한 아키텍처, Workflow
			- 고민할 점
				- 예측 속도 병목 -> 사용자 경험 악화
			- Usecase
				- 예측의 결과에 따라 클라이언트의 로직이 즉각적으로 달라져야 하는 경우
		- Asynchronous 패턴
			![[Pasted image 20241211165305.png]]
			- 구성 요소
				- Queue
					- 클라이언트와 예측 서버 사이에 메시지 시스템(Queue)을 추가
					- 대표적인 메시지 프레임워크 : Apache Kafka
			- 장점
				- 클라이언트와 예측 프로세스 분리
			- 고민할 점
				- 메시지 Queue 시스템을 만들어야함
				- 구조 복잡
				- 완전한 실시간 예측엔 적절하지 않음
			- Usecase
				- 예측과 클라이언트 진행 프로세스의 의존성이 없는 경우 -> 클라이언트와 응답을 반환하는 목적지가 분리된 경우
				- 예측 요청을 하고 응답을 바로 받을 필요가 없는 경우
	- Anti Serving 패턴
		- Online Bigsize 패턴
			- 실시간 대응이 필요한 서비스에 예측이 오래걸리는 모델을 사용하는 경우
			- -> 속도와 비용을 조절해 모델 경량화, 중간 캐시서버 추가, 전처리 분리, 실시간이 아닌 배치로 변경가능한지 검토
		- All-in-one 패턴
			- 하나의 서버에 여러 예측 모델을 띄우는 경우 라이브러리 선택 제한이 존재하며, 장애가 발생할 경우 시스템이 마비됨
			- -> 모델 별로 서버를 분리하여 배포 - Microservice 패턴
